\section{Implementation}\label{sec:implementation}
In this chapter, the implementation of the game engine including the basic framework, graphic rendering and input handling is described.
The implementation of the features of the game itself are shown and the connections between different components is described by using a
UML class diagram.
\\
The game engine was implemented as a separate, independent, enhanceable framework, which could also be used to design other
games.
It provides basic functionality for all features needed to design a game, such as input and system handling, rendering, configuration
classes and managers.
The implementation uses a basic entity-component-system as foundation and enhances this with further features.
The ECS will be explained in detail in~\ref{subsec:entity-component-system}.

\subsection{Entity-Component-System}\label{subsec:entity-component-system}
The entity component system setup can be approached from a top-down point of view.
A scene is the basic class that contains all information about the currently displayed entities and the handlers and systems to be used
in the background.
There exist multiple scenes of different classes, such as scenes for the game view, menu scenes etc., which can be created by
inheriting the base scene class.
Scenes can be added to the game by using the Scene Manager, which is also used to swap between available scenes.
Each scene contains a list of entities, that could be referred to as a database of all available objects.
Entities represent a combination of different data containers, so-called components.
Components are unique to each entity object.
There are some standard entities and components available.

\begin{center}
    \begin{tikzpicture}
        [->, >=stealth', auto, semithick, node distance=3cm]
        \tikzstyle{every node}=[scale=0.7]
        \node (A) {\TBox[fill=white]{C}\TBox[fill=white]{C}\TBox[fill=white]{C}};
        \node (C)[below of=A] {\TBox[fill=white]{C}\TBox[fill=white]{C}\TBox[fill=white]{C}};
        \node (B)[left of=C] {\TBox[fill=white]{C}\TBox[fill=white]{C}\TBox[fill=white]{C}};
        \node (D)[right of=C] {\TBox[fill=white]{C}\TBox[fill=white]{C}\TBox[fill=white]{C}};
        \node (E)[below left of=B] {\TBox[fill=white]{C}\TBox[fill=white]{C}\TBox[fill=white]{C}};
        \node (F)[right of=E] {\TBox[fill=white]{C}\TBox[fill=white]{C}\TBox[fill=white]{C}};
        \node (G)[right of=F] {\TBox[fill=white]{C}\TBox[fill=white]{C}\TBox[fill=white]{C}};
        \node (H)[right of=G] {\TBox[fill=white]{C}\TBox[fill=white]{C}\TBox[fill=white]{C}};
        \node (I)[right of=H] {\TBox[fill=white]{C}\TBox[fill=white]{C}\TBox[fill=white]{C}};
        \node (J)[right of=I] {\TBox[fill=white]{C}\TBox[fill=white]{C}\TBox[fill=white]{C}};
        \path
    (A) edge (B)
    (A) edge (C)
        (A) edge (D)
    \end{tikzpicture}
\end{center}

\subsection{UML Diagram}\label{subsec:uml-diagram}

\subsection{Entities}\label{subsec:entities}
Entities are classes constructed of different components.
The implementation aims to generify often used objects.
Therefore, a variety of different entities has been implemented, which will be explained in this chapter.

\textbf{GUI Entities:} \\
Although somewhat precise, every user interface element was implemented as an entity, given that the game is two-dimensional and doesn't require a differentiation between 2D and 3D rendering.
As a result, UI elements can utilize the existing graphical components without the necessity of adjusting any rendering or component techniques.
\\ \\
\textbf{Simulation Entities:} \\
All elements that are placed on the game grid are considered so-called Simulation Entities.
These entities are built of components to describe the cable port distribution, parameters such as failure ratio and failure detection ratio and grid components, which contain the
entities position as a coordinate in the games' grid-like game field.


\subsection{Components}\label{subsec:components}
All entities are built of a subset of the available components, uniquely attached to each.
The different components will be explained in detail in the following chapter.
\textbf{Render Component:} \\
The \textit{RenderComponent} class stores a list of different graphical objects that are then rendered to the scene.\\
Graphical object classes include subclasses for text, images, animations, hovering, lines and shapes.
These classes contain parameters specifying the appearance, such as location and bounds, colors, images or animations and text.
Each object can be added to the render component multiple times.
The reason for this approach is, that an entity should only contain each component uniquely, however there was the requirement to render multiple graphical
objects per entity, such as having and image which needs to be hovered at times. \\
The render component also implements some methods that can be used to specifically attain a list of graphical object instances of a specified class, similar to the Query
implementation of the entity component system.\\ \\

\textbf{ColliderComponent:} \\
Similar to the \textit{RenderComponent}, the \textit{ColliderComponent} also stores a list of collision objects, which are described by location and bounds.
Each of these collision objects is checked by the \textit{CollisionDetectionSystem} and handled accordingly, e.g.\
hovering and object at the same location as the collision object. \\ \\

\textbf{Sound Component:} \\
The \textit{SoundComponent} class can be attached to any entity that needs to have a sound played at times.
It implements methods to set the state of the sound sample to play, pause or stop and contains the actual sound sample to be used by the \textit{SoundEngine}. \\ \\

\subsection{System}\label{subsec:system}
In comparison to handlers, systems are time-based and triggered with every update loop of the game.
They contain methods for different calculations, game logic or time-based events and actions.
They operate at the same rate as the frame rate of e.g.\ the rendering engine, which is defined by the Game Loops rate.

\subsubsection{Query}\label{subsubsec:query2}
The query system is set up as a static class that can be accessed from anywhere.
It implements methods that can be used to search for all entities of a class or entities that have a specified component
attached to it within the currently displayed scene.
The volume of entities can be seen as a database that is filtered by the query system to obtain only the needed components / entities
for other systems. \todo{add graphic with database of ecs}

\subsubsection{Action System}\label{subsubsec:action-system}
Handlers are input listeners, which are event based.
They can be implemented for different purposes, such as keyboard, mouse or controller inputs in general, but also to direct inputs by the user
to a category, such as inputs for levels that trigger methods within the level itself, inputs to buttons or hovering over entities.
They provide user inputs to manipulate the systems. \todo{rewrite}
\subsubsection{Simulation System}\label{subsubsec:simulation-system}

\subsubsection{Markov Processor}\label{subsubsec:example-markov-chains}
In the following chapter, some examples for Markov chains that reflect the level designs will be shown and the implementation of the
MarkovProcessor will be explained by using these graphs.
\subsubsection{Build System}\label{subsubsec:build-system}

\subsubsection{Rendering Engine}\label{subsubsec:graphics-engine}
The Rendering Engine is the main part of all graphical components.
It implements different engines for each graphical object (shape, image, text, line) that are called depending on the available data within the
context.
All content is rendered to a JPanel object by using the Graphics2D instance available by default.
There are several options and parameters for rendering quality and display sizes that are considered during rendering.
A rendering cycle looks as follows:
- query relevant entities (entities containing the GraphicsComponent)
- determine the available data per entity
- send the data to the according renderer
\\ \\
There are different layers to be considered by the rendering engine.
The layers include background layers, multiple game layers and UI layers, both including a separate layer for hovering.
The rendering engine renders objects starting from the background layer, going all the way to the front-most layer - UI hovering, as seen in figure
\todo{add figure}.

\subsubsection{Sound Engine}\label{subsubsec:sound-engine}

\subsection{Input Handling}\label{subsec:input-handling}

\subsection{Game Loop}
The game loop
\subsection{Data Storage \& Data Parsing}\label{subsec:data-storage-&-data-parsing}
It was chosen to save and load resources from XML files, due to the benefits of this file format.
XML stands for eXtensible Markup Language, and it is a markup language that is used for encoding documents in a format that is both human-readable and machine-readable.
It was designed to be flexible and extensible, allowing developers to create their own markup tags and structure data in a way that is specific to their needs.
\\
XML documents are made up of elements, which are enclosed in opening and closing tags, and attributes, which provide additional information about the element.
The structure of an XML document is defined by a Document Type Definition (DTD) or an XML Schema, which specifies the elements and attributes that are allowed in the document and the relationships between them.
\\
One of the main benefits of XML is its ability to store and transfer data in a standardized format that can be easily parsed by different software applications, regardless of the platform, and there are
already multiple implementations available to successfully do this, including JAVA's built-in library for DOM parsing.
\\
The structure of the different XML files for levels, tilesets, scores and language used in this project will be explained in the next chapters.
\subsubsection{Tileset}\label{subsubsec:tileset}
A tileset file contains a list of multiple tile nodes, which each have an id and a type attribute.
A tile always contains exactly one image node, which has at least width, height and a resource path to an image assigned to it.
Optionally, there can also be a description attribute which can be used to set a tooltip that will be rendered to the games tooltip panel, if available.
\\ \\
\subsubsection{Level Files}\label{subsubsec:level-files}
The root node of a level structure is the map node, which always contains attributes to assign an id, a name, a difficulty (tutorial, easy, medium, hard or custom) and a
grid width and height for the games grid.
The map node contains one sub node for descriptions (and description parts, if the text for a description should be split up into multiple displayable parts),
one sub node for available elements to build from the build panel and one sub node that defines the already available objects on the grid.
Additionally, the goal and goal definition sub nodes contain information on how to pass a level (i.e.\ safety requirement, minimum components that should be working correctly and
maximum ouf of control components).
Furthermore, the tileset used by this map needs to be defined in the tileset sub node and unlocks (i.e.\ which level ids are unlocked after passing this level) can be defined.
\\ \\
\subsubsection{Language Files}\label{subsubsec:language-files}

\subsubsection{Score Files}\label{subsubsec:score-files}

\subsubsection{Parsing}\label{subsubsec:parsing}

\subsubsection{Level}
\subsubsection{Profile}
\subsection{External Device Inputs}\label{subsec:external-device-inputs}
\subsubsection{Mouse \& Keyboard}\label{subsubsec:mouse-&-keyboard}
The standard input device for the game are mouse and keyboard.
\subsubsection{Gamepad Integration}\label{subsubsec:gamepad-integration}
The game was designed for was keyboard and mouse, however due to the easy accessibility requirement, it was chosen to also implement gamepad integration.
For gamepad integration, the open source library \textit{Jamepad} is used.
It automatically detects most USB controller devices and has an inbuilt button mapping which can be used in the implementation.
A separate thread with a capture rate for controls which is equal and synchronized to the games' FPS is implemented to queue all controller
events to the game engines' event queue and action system, where they are handled.
Button handling is mostly implemented in a way that a button press creates a new mouse event and the cursor position which is then handled by the action
systems' mouse event handling method.
This reduces maintenance and new implementation of buttons and actions, while being guaranteed to work correctly with all devices.

\subsection{Simulation}
\subsection{Programming Language}\label{subsec:programming-language}
The programming language that was chosen up front is \textit{JAVA}.
This decision was made based on the fact that it makes sense to have a) an object-oriented programming language in order to
handle entities easily and b) because it is possible to run the program on almost every system due to \textit{JAVA} running
in a virtual machine.



