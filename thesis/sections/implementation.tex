\section{Game Design \& Development}\label{sec:implementation}
In this chapter, the implementation of the game engine including the basic framework, graphic rendering and input handling is described.
The implementation of the features of the game itself are shown and the connections between different components is described by using a
UML class diagram.

\subsection{General Approach}\label{subsec:general-approach}
The game engine was implemented as a separate, independent, enhanceable framework, which may also be used to design other
games.
It provides basic functionality for all features needed to design a game, such as input and system handling, rendering, configuration
classes and managers.
The implementation uses a basic entity-component-system as foundation and enhances this with further features.

\subsubsection{Programming Language}\label{subsubsec:programming-language}
The programming language that was chosen for this implementation is \textit{JAVA} \\

Java is a high-level, object-oriented programming language that was originally developed by Sun Microsystems (now owned by Oracle Corporation) in the mid-1990s.
It is designed to be portable, meaning that it can be run on a wide variety of platforms, including Windows, macOS, Linux, and many others, without needing to be recompiled for each platform.
\\
Java is widely used for developing both desktop and web-based applications, as well as mobile applications for Android devices.
It is also used extensively in server-side programming and for building enterprise applications.
\\
One of the key features of Java is its virtual machine (VM), which allows Java programs to be executed on any system that has a compatible JVM installed, regardless of the underlying hardware and operating system.
This makes it possible to write a single Java program that can run on multiple platforms, without needing to be modified for each one.
\\
Java also has a large standard library of classes and functions, which makes it easier to write complex programs without needing to reinvent the wheel.
Additionally, Java is known for its strong emphasis on security, which makes it a popular choice for building applications that need to be highly secure and resistant to cyber attacks.
\\
The decision to use Java was made based on the fact that it makes sense to have a) an object-oriented programming language in order to
handle entities easily and b) because it is possible to run the program on almost every system due to \textit{JAVA} running
in a virtual machine.

\subsection{Game Engine}\label{subsec:game}
The game engine implements a variety of methods and classes which are used for handling the general program execution, independent of the actual game implementation.
In this chapter, these classes will be explained in detail and the general concept of the engine is reviewed.

\subsection{Game Implementation}\label{subsec:game-implementation}

\subsection{Entity-Component-System}\label{subsec:entity-component-system}
The entity component system setup can be approached from a top-down point of view.
A scene is the basic class that contains all information about the currently displayed entities and the handlers and systems to be used
in the background.
There exist multiple scenes of different classes, such as scenes for the game view, menu scenes etc., which can be created by
inheriting the base scene class.
Scenes can be added to the game by using the Scene Manager, which is also used to swap between available scenes.
Each scene contains a list of entities, that could be referred to as a database of all available objects.
Entities represent a combination of different data containers, so-called components, which can be uniquely attached to each entity.
There are some standard entities and components available directly via the engine, however there may be the need for more components and entities while implementing the actual game.

\subsection{UML Diagram}\label{subsec:uml-diagram}
The following figure shows the structure of the entity component system implemented in this solution.
\todo{add uml}

\subsection{Entities}\label{subsec:entities}
Entities are classes constructed of different components.
The implementation aims to generify often used objects.
Therefore, a variety of different entities has been implemented, which will be explained in this chapter.

\textbf{GUI Entities:} \\
Although somewhat precise, every user interface element was implemented as an entity, given that the game is two-dimensional and doesn't require a differentiation between 2D and 3D rendering.
As a result, UI elements can utilize the existing graphical components without the necessity of adjusting any rendering or component techniques.
\\ \\
\textbf{Simulation Entities:} \\
All elements that are placed on the game grid are considered so-called Simulation Entities.
These entities are built of components to describe the cable port distribution, parameters such as failure ratio and failure detection ratio and grid components, which contain the
entities position as a coordinate in the games' grid-like game field.
Furthermore, graphics and colliders are available to simulation entity objects.
\\ \\
\textbf{Build Panel Entities:} \\
Build Panel Entities are entities which are available in the players' inventory and can be used for building objects on the game grid.
They include components for graphics description, build information - e.g.\ the failure ratio, failure detection ratio and amount in inventory,
and colliders.

\subsection{Components}\label{subsec:components}
All entities are built of a subset of the available components, uniquely attached to each.
The different components will be explained in detail in the following chapter.
\textbf{Render Component:} \\
The \textit{RenderComponent} class stores a list of different graphical objects that are then rendered to the scene.\\
Graphical object classes include subclasses for text, images, animations, hovering, lines and shapes.
These classes contain parameters specifying the appearance, such as location and bounds, colors, images or animations and text.
Each object can be added to the render component multiple times.
The reason for this approach is, that an entity should only contain each component uniquely, however there was the requirement to render multiple graphical
objects per entity, such as having and image which needs to be hovered at times. \\
The render component also implements some methods that can be used to specifically attain a list of graphical object instances of a specified class, similar to the Query
implementation of the entity component system.\\ \\

\textbf{ColliderComponent:} \\
Similar to the \textit{RenderComponent}, the \textit{ColliderComponent} also stores a list of collision objects, which are described by location and bounds.
Each of these collision objects is checked by the \textit{CollisionDetectionSystem} and handled accordingly, e.g.\
hovering and object at the same location as the collision object. \\ \\

\textbf{Sound Component:} \\
The \textit{SoundComponent} class can be attached to any entity that needs to have a sound played at times.
It implements methods to set the state of the sound sample to play, pause or stop and contains the actual sound sample to be used by the \textit{SoundEngine}. \\ \\

\textbf{Action Component:} \\
Action Components are used for storing a mapping of input to action within an entity, e.g.\ clicking a button which opens another scene.
Each Action Component is processed by the ActionSystem. \\ \\

\textbf{Cursor Component:} \\
The cursor component is a component used for handling game pad inputs and acts as a virtual mouse cursor, which can be moved by using
joysticks of game pads or keyboard buttons.
It simply indicates the position, where new mouse events are generated, when the actual mouse is not used. \\ \\

\subsection{System}\label{subsec:system}
Systems are time-based and triggered with every update loop of the game.
They contain methods for different calculations, game logic or time-based events and actions.
They operate at the same rate as the frame rate of e.g.\ the rendering engine, which is defined by the Game Loops rate.
Systems do not have specific handling methods for input types, they operate solely time-based.

\subsubsection{Query}\label{subsubsec:query2}
The query system is set up as a static class that can be accessed from anywhere.
It implements methods that can be used to search for all entities of a class or entities that have a specified component
attached to it within the currently displayed scene.
The volume of entities can be seen as a database that is filtered by the query system to obtain only the needed components / entities
for other systems. \todo{add graphic with database of ecs}

\subsubsection{Action System}\label{subsubsec:action-system}
Handlers are input listeners, which are event based.
They can be implemented for different purposes, such as keyboard, mouse or controller inputs in general, but also to direct inputs by the user
to a category, such as inputs for levels that trigger methods within the level itself, inputs to buttons or hovering over entities.
They provide user inputs to manipulate the systems. \todo{rewrite}


\subsubsection{Simulation System}\label{subsubsec:simulation-system}

\subsubsection{Markov Processor}\label{subsubsec:example-markov-chains}
In the following chapter, some examples for Markov chains that reflect the level designs will be shown and the implementation of the
MarkovProcessor will be explained by using these graphs.

\subsection{Handler}\label{subsec:handler}
In comparison to systems, handlers may act differently based on the current input events in queue.
The Input Manager contains a list of handlers, which is iterated during each game loop step for each event currently the in the games' input event queue.
Handlers implement methods for handling Key Events, Mouse Events and Input Actions (i.e.\ Gamepad Events) differently, since they may need different processing.

\subsubsection{Build Handler}\label{subsubsec:build-handler}


\subsection{Scene}\label{subsec:scenes}
A scene is a collection of entities that together form an aspect of the game, e.g.\ a menu or a level.
The \textit{Scene} class is an abstract class implementing methods for adding and removing entities from itself.
The scenes in this implementation can be categorized in two general sets: menu scenes and game scenes.

\\
To add a scene to the game, a scene object needs to be instantiated and added to the games' \textit{SceneManager}, where all
scenes are stored and the currently active scene can be set.
Generally, all systems access the scene manager to only process the currently active scene.
\\

Scenes are implemented in a hierarchy which is shown in figure \todo{add figure}.
\subsection{Input Handling}\label{subsec:input-handling}

\subsection{Game Loop}\label{subsec:game-loop}
The game loop packs all the different systems and handlers used in the game and executes them in a given order at every time stamp
$t_{i} = t_{i-1} + \delta t$, where $\delta t$ is the execution rate defined for the game.
In this implementation, $\delta t$ is defined as $\delta t = 1000 / 240 ms = 4.1667 ms$, which equals 240 frames per second.
\\
Input handling is executed in a separate thread and handles inputs at a rate of $\delta t_{inputs} = 20 ms$, since inputs in between two frames
would otherwise not be received by the games' input handling system.
\\ \\
The following execution order is defined in the game loop:

\begin{enumerate}
    \item Input Handling
    \item System Handling
    \item Scene Update \& Repaint
    \item Play Sounds
\end{enumerate}

\subsection{Engines \& Managers}\label{subsec:engines}
Engines and managers are components used for handling different aspects of the game, such as graphics rendering, playing audio streams
or switching scenes.
In this chapter, the engines and managers used in the implementation will be reviewed in detail.

\subsubsection{Rendering Engine}\label{subsubsec:graphics-engine}
The Rendering Engine is the main part of all graphical components.
It implements different engines for each graphical object (shape, image, text, line) that are called depending on the available data within the
context.
All content is rendered to a JPanel object by using the Graphics2D instance available by default.
There are several options and parameters for rendering quality and display sizes that are considered during rendering.
A rendering cycle looks as follows:
- query relevant entities (entities containing the GraphicsComponent)
- determine the available data per entity
- send the data to the according renderer
\\ \\
There are different layers to be considered by the rendering engine.
The layers include background layers, multiple game layers and UI layers, both including a separate layer for hovering.
The rendering engine renders objects starting from the background layer, going all the way to the front-most layer - UI hovering, as seen in figure
\todo{add figure}.

\subsubsection{Sound Engine}\label{subsubsec:sound-engine}

\subsection{Data Storage \& Data Parsing}\label{subsec:data-storage-&-data-parsing}
It was chosen to save and load resources from XML files, due to the benefits of this file format.
XML stands for eXtensible Markup Language, and it is a markup language that is used for encoding documents in a format that is both human-readable and machine-readable.
It was designed to be flexible and extensible, allowing developers to create their own markup tags and structure data in a way that is specific to their needs.
\\
XML documents are made up of elements, which are enclosed in opening and closing tags, and attributes, which provide additional information about the element.
The structure of an XML document is defined by a Document Type Definition (DTD) or an XML Schema, which specifies the elements and attributes that are allowed in the document and the relationships between them.
\\
One of the main benefits of XML is its ability to store and transfer data in a standardized format that can be easily parsed by different software applications, regardless of the platform, and there are
already multiple implementations available to successfully do this, including JAVA's built-in library for DOM parsing.
\\
The structure of the different XML files for levels, tilesets, scores and language used in this project will be explained in the next chapters.
\subsubsection{Tileset}\label{subsubsec:tileset}
A tileset file contains a list of multiple tile nodes, which each have an id and a type attribute.
A tile always contains exactly one image node, which has at least width, height and a resource path to an image assigned to it.
Optionally, there can also be a description attribute which can be used to set a tooltip that will be rendered to the games tooltip panel, if available.
\\
The following example shows a tileset with a single tile of the type CPU, including its description and image parameters.
\\ \\
\begin{lstlisting}[language=XML,label={lst:tileset-xml}]
    <?xml version="1.0" encoding="UTF-8"?>
    <tileset name="tiles">
        <tile id="200" type="CPU">
            <image width="32" height="32" source="res/avionics/default.png" description="Default CPU Component"/>
        </tile>
    </tileset>
\end{lstlisting}
\subsubsection{Level Files}\label{subsubsec:level-files}
The root node of a level structure is the map node, which always contains attributes to assign an id, a name, a difficulty (tutorial, easy, medium, hard or custom) and a
grid width and height for the games grid.
The map node contains one sub node for descriptions (and description parts, if the text for a description should be split up into multiple displayable parts),
one sub node for available elements to build from the build panel and one sub node that defines the already available objects on the grid.
Additionally, the goal and goal definition sub nodes contain information on how to pass a level (i.e.\ safety requirement, minimum components that should be working correctly and
maximum ouf of control components).
Furthermore, the tileset used by this map needs to be defined in the tileset sub node and unlocks (i.e.\ which level ids are unlocked after passing this level) can be defined.
\\
The below code shows an example on the structure of the level xml files, which describes a 5 by 3 game grid with one actuator
at position $x = 4$ and $y = 1$, and two sensors at positions $x = 0$ and $y = [0, 2]$.
\\
Note, that the width and height attributes represent the actual size of the map, similar to the length of an array in Java, while
the positions show the position in the grid starting at 0, similar to indexes in Java arrays.
\\
\\
\begin{lstlisting}[language=XML,label={lst:level-xml}]
    <?xml version="1.0" encoding="UTF-8"?>
    <map id="0" name="@0" width="5" height="3" difficulty="EASY">
        <description>
            <part>@1</part>
        </description>
        <goal>1e-7</goal>
        <goalDefinition workingActuators="1" workingSensors="0" workingComputers="0"/>
        <tileset source="base_tiles.xml"/>
        <unlocks>
            <unlock>6</unlock>
        </unlocks>
        <build>
            <entity id="500" amount="1000" safety="0" correctSignalsNeeded="1" outOfControlSignalsAccepted="0"/>
            <entity id="501" amount="1000" safety="0" correctSignalsNeeded="1" outOfControlSignalsAccepted="0"/>
            <entity id="502" amount="1000" safety="0" correctSignalsNeeded="1" outOfControlSignalsAccepted="0"/>
            <entity id="203" amount="2" safety="0" failureDetectionRatio="1" correctSignalsNeeded="1"
                    outOfControlSignalsAccepted="0"/>
        </build>
        <layer id="0" name="Tile Layer 1">
            <entity x="0" y="0" id="201" interactable="false" safety="1e-4" failureDetectionRatio="1"
                    correctSignalsNeeded="0" outOfControlSignalsAccepted="0"/>
            <entity x="0" y="2" id="201" interactable="false" safety="1e-4" failureDetectionRatio="1"
                    correctSignalsNeeded="0" outOfControlSignalsAccepted="0"/>
            <entity x="4" y="1" id="205" interactable="false" safety="0" failureDetectionRatio="1" correctSignalsNeeded="2"
                    outOfControlSignalsAccepted="0"/>
        </layer>
    </map>
\end{lstlisting}
\subsubsection{Language Files}\label{subsubsec:language-files}
A language file contains all text content used in the game for a specified language.
In the root node, the language type can be given according to the IETF language tag \todo{add source}, if supported by the game (i.e.\ implemented in the language manager).
Within this root node, string nodes are created which contain the id of a string as an attribute and the actual content as text.
Each of the ids has to be unique, otherwise only the first specified id will be considered in the implementation.
\\
\\
\begin{lstlisting}[language=XML,label={lst:lang-xml}]
    <strings language="">
        <string id="1">Sample Text</string>
    </strings>
\end{lstlisting}

\subsubsection{Score Files}\label{subsubsec:score-files}
Highscores for each level are saved in a separate xml file containing information about the profile name, score and level id.
The following structure is used for this file, saving the score 91 for a user who played level id one.
\\ \\
\begin{lstlisting}[language=XML,label={lst:score-xml}]
    <scores>
      <scoreItem>
        <name>User</name>
        <score>91</score>
        <level>1</level>
      </scoreItem>
    </scores>
\end{lstlisting}

\subsubsection{Parsing}\label{subsubsec:parsing}

\subsubsection{Level}
\subsubsection{Profile}
\subsection{External Device Inputs}\label{subsec:external-device-inputs}
\subsubsection{Mouse \& Keyboard}\label{subsubsec:mouse-&-keyboard}
The standard input device for the game are mouse and keyboard.
\subsubsection{Gamepad Integration}\label{subsubsec:gamepad-integration}
The game was designed for was keyboard and mouse, however due to the easy accessibility requirement, it was chosen to also implement gamepad integration.
For gamepad integration, the open source library \textit{Jamepad} is used.
It automatically detects most USB controller devices and has an inbuilt button mapping which can be used in the implementation.
A separate thread with a capture rate for controls which is equal and synchronized to the games' FPS is implemented to queue all controller
events to the game engines' event queue and action system, where they are handled.
Button handling is mostly implemented in a way that a button press creates a new mouse event and the cursor position which is then handled by the action
systems' mouse event handling method.
This reduces maintenance and new implementation of buttons and actions, while being guaranteed to work correctly with all devices.


