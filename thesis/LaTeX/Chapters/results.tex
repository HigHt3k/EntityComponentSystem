\chapter{Results}\label{ch:results}
\section{Educational Achievements}\label{sec:educational-achievements}
\section{Limitations}\label{sec:limitations}
The field of aircraft system engineering is vast and intricate, and this work aims to simplify this complex subject by narrowing its scope.
Various failure types (such as mechanical or electrical failures) are considered only as a generalized failure of any type.
However, different failures may result in diverse system behaviors, which must be analyzed in real-life situations.
\\
While incorporating multiple failure types could be a potential future feature, it would considerably slow down the current
approach of Markov generation, as explained in~\ref{subsubsec:example-markov-chains}.
The implementation is based on generating Markov chains that grow in size as the number of components in the system increases.
Introducing multiple failure types would further raise the complexity of the Markov chain, resulting in approximately $m^n$ more states,
where $m$ represents the number of distinct failure states and $n$ the number of components.
\todo{check if that is true, adapt equations}

\section{Challenges}\label{sec:challenges}
During the implementation process, some major challenges - not only negative, also in a positive way - occurred, which will be described in this chapter, to give an
overview and a guideline on what may be done differently during the next iteration of the project or during the development of other
applications and what may be done in a similar way, as it worked well.
\subsection{Game Engine Development}\label{subsec:entity-component-system-challenges}
One major part of this work was the implementation of a game engine, using the entity-component system approach in a similar way
Unity handles its GameObjects.
This resulted in a very structured and extendable framework, which servers as a good baseline and enables the development of the actual game.
As much as this provides flexibility, it is also a lot of work that went into a part of the implementation, that to the user
does not provide any obvious benefits, as there is nothing which is actually visible from this implementation approach.
However, the new implementation of a game engine was ultimately chosen due to the overwhelming amount of features and complexity
already existing game engines provide, where only a very small subset would be used for developing the actual game, and other problems
may have occurred due to the relatively specific use case of this work.
Eventually, finishing the work with a game engine that can be used for any further developments of the game without having to worry
about the implementation of the engine is a benefit especially for further development and feature implementations.

\subsection{Programming Language}\label{subsec:programming-language}
Another challenge was the usage of Java itself, as this was mainly chosen due to already existing coding knowledge with this
language and a great availability of already existing libraries, such as rendering libraries.
Furthermore, Java is a very understandable and readable language and applications can easily be used on most devices, which are great benefits.
However, other languages such as C++ or C\# may be more suitable for game development in general, which is not only shown by
the usage of languages in the modern gaming industry (e.g. Minecraft was originally created in Java, but is now also switching to C++), but
also by the general performance of methods.
Due to Java being interpreted, most methods, in this work this is especially mentionable for the simulation part of the game, are being slowed down
by a margin compared to other languages like C++.
To correctly assess this, these methods would also need to be implemented in other languages, however the above-mentioned would
be the expected result.